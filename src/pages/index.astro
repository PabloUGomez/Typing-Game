---
import Layout from './layouts/Layout.astro'
---

<Layout title='Typing Game'>
  <main class='text-white flex flex-col justify-center items-center'>
    <section id='game' class='text-2xl mt-20 max-w-4xl'>
      <time class='text-yellow'></time>
      <p class='font-medium flex flex-wrap gap-x-2 m-0 text-pretty mb-10'></p>
      <input autofocus class='-z-50 opacity-0 pointer-events-none' />
      <div class='flex justify-center gap-2 my-2 w-full'>
        <kbd class='kbd'>q</kbd>
        <kbd class='kbd'>w</kbd>
        <kbd class='kbd'>e</kbd>
        <kbd class='kbd'>r</kbd>
        <kbd class='kbd'>t</kbd>
        <kbd class='kbd'>y</kbd>
        <kbd class='kbd'>u</kbd>
        <kbd class='kbd'>i</kbd>
        <kbd class='kbd'>o</kbd>
        <kbd class='kbd'>p</kbd>
      </div>
      <div class='flex justify-center gap-2 my-2 w-full'>
        <kbd class='kbd'>a</kbd>
        <kbd class='kbd'>s</kbd>
        <kbd class='kbd'>d</kbd>
        <kbd class='kbd'>f</kbd>
        <kbd class='kbd'>g</kbd>
        <kbd class='kbd'>h</kbd>
        <kbd class='kbd'>j</kbd>
        <kbd class='kbd'>k</kbd>
        <kbd class='kbd'>l</kbd>
      </div>
      <div class='flex justify-center gap-2 my-2 w-full'>
        <kbd class='kbd'>z</kbd>
        <kbd class='kbd'>x</kbd>
        <kbd class='kbd'>c</kbd>
        <kbd class='kbd'>v</kbd>
        <kbd class='kbd'>b</kbd>
        <kbd class='kbd'>n</kbd>
        <kbd class='kbd'>m</kbd>
      </div>
    </section>
    <section
      id='results'
      class='w-2/3 flex justify-center items-center my-20 mx-32'
    >
      <samp class='text-left flex justify-around w-full font-semibold text-5xl'>
        <span class='flex gap-3'>
          <h2>wrp</h2>
          <h3></h3>
        </span>
        <span class='flex gap-3'>
          <h2>accuracy</h2>
          <h3 id='result-accuracy'></h3></span
        >
      </samp>
      <div
        class='chart-container flex justify-center items-center mt-16 mb-10'
        style='position: relative; height:50vh; width:100vw'
      >
        <canvas id='myChart'></canvas>
      </div>

      <button
        id='restart-button'
        class='rounded-md px-4 py-2 hover:bg-gray w-32'>Try Again</button
      >
    </section>
  </main>
</Layout>
<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>

<script>
  import Chart from 'chart.js/auto'
  import { words as INITIAL_WORDS } from './store/data.js'

  const time = document.querySelector('time')
  const paragraph = document.querySelector('p')
  const input = document.querySelector('input')
  const game = document.querySelector('#game') as HTMLElement
  const results = document.querySelector('#results') as HTMLElement
  const accuracy = results.querySelector('#result-accuracy')
  const wpm = results.querySelector('h3')
  const restartButton = results.querySelector('button')
  const keyboard = document.querySelectorAll('.kbd')
  const INITIAL_TIME = 30

  let words = []
  let currentTime = INITIAL_TIME

  startGame()
  initEvents()

  restartButton.addEventListener('click', () => {
    game.style.display = 'block'
    results.style.display = 'none'
    startGame()
  })

  function startGame() {
    words = [...INITIAL_WORDS]
    currentTime = INITIAL_TIME
    words = INITIAL_WORDS.toSorted(() => Math.random() - 0.5).slice(0, 50)
    currentTime = INITIAL_TIME

    time.textContent = currentTime.toString()

    paragraph.innerHTML = words
      .map((word) => {
        const letters = word.split('')

        return `<word>
        ${letters.map((letter) => `<letter>${letter}</letter>`).join('')}
      </word>`
      })
      .join('')

    const firstWord = document.querySelector('word')
    firstWord.classList.add('active')
    firstWord.querySelector('letter').classList.add('active')

    const wpr = []
    const intervalId = setInterval(() => {
      let wordsInSecond = 0
      currentTime--
      time.textContent = currentTime.toString()
      const lettersCorrectNotInChart = paragraph.querySelectorAll(
        'letter.correct:not(.in-chart)'
      ).length
      wordsInSecond = lettersCorrectNotInChart / 6
      wpr.push(wordsInSecond * 60)
      if (currentTime <= 0) {
        clearInterval(intervalId)
        gameOver(wpr)
      }
      paragraph.querySelectorAll('letter.correct').forEach((element) => {
        element.classList.add('in-chart')
      })
    }, 1000)
  }

  function initEvents() {
    document.addEventListener('keydown', (event) => {
      input.focus()
    })
    input.addEventListener('keydown', onKeyDown)
    input.addEventListener('keyup', onKeyUp)
  }

  function onKeyUp(event) {
    const { key } = event

    keyboard.forEach((kbd) => {
      kbd.classList.remove('clicked')
      if (kbd.textContent === key) {
        kbd.classList.add('clicked')
      }
    })
    const currentWord = document.querySelector('word.active')
    const currentLetter = currentWord.querySelector('letter.active')

    const wordLength = currentWord.textContent.trim()
    input.maxLength = wordLength.length

    const allLetters = currentWord.querySelectorAll('letter')

    allLetters.forEach((letter) =>
      letter.classList.remove('correct', 'incorrect')
    )

    input.value.split('').forEach((char, index) => {
      const letter = allLetters[index]
      const letterToCheck = wordLength[index]

      const isCorrect = char === letterToCheck
      const classToAdd = isCorrect ? 'correct' : 'incorrect'
      isCorrect && letter.classList.remove('marked')
      letter.classList.add(classToAdd)
    })

    currentLetter.classList.remove('active', 'is-last')
    const inputLength = input.value.length
    const nextActiveLetter = allLetters[inputLength]

    if (nextActiveLetter) {
      nextActiveLetter.classList.add('active')
    } else {
      currentLetter.classList.add('active', 'is-last')
    }
  }

  function onKeyDown(event) {
    const currentWord = document.querySelector('word.active')
    const currentLetter = currentWord.querySelector('letter.active')
    const { key } = event

    if (key === ' ') {
      event.preventDefault()

      const nextWord = currentWord.nextElementSibling
      const nextLetter = nextWord.querySelector('letter')

      currentWord.classList.remove('active', 'marked')
      currentLetter.classList.remove('active')
      currentWord.querySelectorAll('letter:not(.correct)').forEach((el) => {
        el.classList.add('marked')
      })

      nextWord.classList.add('active')
      nextLetter.classList.add('active')

      input.value = ''

      const hasMissedLetters =
        currentWord.querySelectorAll('letter:not(.correct)').length > 0
      const classToAdd = hasMissedLetters ? 'marked' : 'correct'
      currentWord.classList.add(classToAdd)
    }

    if (key === 'Backspace') {
      const prevWord = currentWord.previousElementSibling
      const prevLetter = currentLetter.previousElementSibling
      const wordMarked = paragraph.querySelector('word.marked')

      if (!prevWord && !prevLetter) {
        event.preventDefault()
        return
      }

      if (wordMarked && !prevLetter) {
        event.preventDefault()
        prevWord.classList.remove('marked')
        prevWord.classList.add('active')

        const letterToGo = prevWord.querySelector('letter:last-child')
        currentLetter.classList.remove('active')
        letterToGo.classList.add('active')

        input.value = [
          ...prevWord.querySelectorAll('letter.correct, letter.incorrect'),
        ]
          .map((el) => {
            return el.classList.contains('correct') ? el.textContent : '`'
          })
          .join('')
      }
    }
  }

  function gameOver(wpr) {
    game.style.display = 'none'
    results.style.display = 'flex'

    const correctWords = paragraph.querySelectorAll('word.correct').length
    const correctLetters = paragraph.querySelectorAll('letter.correct').length
    const markedLetters = [
      ...paragraph.querySelectorAll('letter:not(.incorrect)'),
    ].filter((el) => el.classList.contains('marked')).length

    const incorrectLetters =
      paragraph.querySelectorAll('letter.incorrect').length
    const totalLetters = correctLetters + incorrectLetters + markedLetters

    const accuracyValue = totalLetters > 0 ? correctLetters / totalLetters : 0
    const wpmValue = Math.round(correctWords * (60 / INITIAL_TIME))
    const ctx = document.getElementById('myChart') as HTMLCanvasElement
    const labels = []
    for (let i = 0; i <= INITIAL_TIME; i++) labels.push(i)

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Words per minute',
            data: wpr,
            borderWidth: 1,
          },
        ],
      },
      options: {
        animations: {
          tension: {
            duration: 1000,
            easing: 'linear',
            from: 1,
            to: 0,
            loop: true,
          },
        },
        scales: {
          y: {
            // defining min and max so hiding the dataset does not change scale range
            min: 0,
            max: 70,
          },
        },
        layout: {
          padding: 5,
        },
      },
    })
    accuracy.textContent = `${(accuracyValue * 100).toFixed(2)}%`
    wpm.textContent = wpmValue.toString()
  }
</script>

<style is:global>
  :root {
    color-scheme: light dark;
    --green: #00b755;
    --yellow: #daaf38;
    --red: #ca4754;
    --black: #222;
    --gray: #999;
  }
  #game {
    display: block;
  }
  #results {
    display: none;
    flex-direction: column;
  }
  word {
    border-bottom: 1.5px solid transparent;
    transition: border-color 0.3s ease-in-out;
    &.marked {
      border-bottom: solid 2px var(--red);
    }
  }
  letter {
    color: var(--gray);
    position: relative;
    &.active::before {
      content: '|';
      color: var(--yellow);
      position: absolute;
      left: -62%;
      animation: 1s blink infinite ease-in-out;
    }
    &.is-last::before {
      left: 65%;
    }
    &.correct {
      color: var(--green);
    }
    &.incorrect {
      color: var(--red);
    }
  }
  .clicked {
    animation: pulse 0.7s ease-in-out;
  }

  .kbd {
    min-width: 4rem;
    min-height: 4rem;
  }

  @keyframes pulse {
    0% {
      background-color: var(--black);
    }
    50% {
      background-color: var(--gray);
    }
    100% {
      background-color: var(--black);
    }
  }
  @keyframes blink {
    0%,
    25% {
      opacity: 1;
    }
    75% {
      opacity: 0;
    }
  }
</style>
